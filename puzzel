
from queue import Queue, PriorityQueue
import copy

# Goal state
goal = [[1,2,3],[4,5,6],[7,8,0]]

# Moves
moves = [(-1,0),(1,0),(0,-1),(0,1)] # up, down, left, right

def find_zero(state):
    for i in range(3):
        for j in range(3):
            if state[i][j]==0:
                return i,j

def is_goal(state):
    return state == goal

def state_to_tuple(state):
    return tuple(tuple(row) for row in state)

# DFS
def dfs(start):
    stack = [(start, [])]
    visited = set()
    while stack:
        state,path = stack.pop()
        visited.add(state_to_tuple(state))
        if is_goal(state):
            return path + [state]
        x,y = find_zero(state)
        for dx,dy in moves:
            nx,ny = x+dx, y+dy
            if 0<=nx<3 and 0<=ny<3:
                new_state = copy.deepcopy(state)
                new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
                if state_to_tuple(new_state) not in visited:
                    stack.append((new_state, path+[state]))
    return None

# BFS
def bfs(start):
    queue = Queue()
    queue.put((start, []))
    visited = set()
    visited.add(state_to_tuple(start))
    while not queue.empty():
        state,path = queue.get()
        if is_goal(state):
            return path + [state]
        x,y = find_zero(state)
        for dx,dy in moves:
            nx,ny = x+dx, y+dy
            if 0<=nx<3 and 0<=ny<3:
                new_state = copy.deepcopy(state)
                new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
                t = state_to_tuple(new_state)
                if t not in visited:
                    visited.add(t)
                    queue.put((new_state, path+[state]))
    return None

# A* with Manhattan distance
def manhattan(state):
    dist = 0
    for i in range(3):
        for j in range(3):
            if state[i][j]!=0:
                x,y = divmod(state[i][j]-1,3)
                dist += abs(x-i)+abs(y-j)
    return dist

def a_star(start):
    open_set = PriorityQueue()
    open_set.put((manhattan(start), 0, start, []))
    visited = set()
    while not open_set.empty():
        f,g,state,path = open_set.get()
        if is_goal(state):
            return path + [state]
        visited.add(state_to_tuple(state))
        x,y = find_zero(state)
        for dx,dy in moves:
            nx,ny = x+dx, y+dy
            if 0<=nx<3 and 0<=ny<3:
                new_state = copy.deepcopy(state)
                new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
                t = state_to_tuple(new_state)
                if t not in visited:
                    h = manhattan(new_state)
                    open_set.put((g+1+h, g+1, new_state, path+[state]))
    return None

# Example initial state
start_state = [[1,2,3],[4,0,6],[7,5,8]]

print("DFS Path length:", len(dfs(start_state)))
print("BFS Path length:", len(bfs(start_state)))
print("A* Path length:", len(a_star(start_state)))
